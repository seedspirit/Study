'''
이 문제는 그냥 못 풀었다;; 

전에 상하좌우도 그렇고 뭔가 핵심은 알 것 같은데 그걸 구현을 못하겠단 말이지... 풀이를 외우던가 해야지 원 
''''
 
'''
1-1. 내 풀이
'''
n, m = input().split()

count = 0

n = [a, b, c, d, e, f, g, h]
m = [1, 2, 3, 4, 5, 6, 7, 8]

"""
움직일 수 있는 경우의 수는
m+2, n-1
m-2, n-1
m-2, n+1
m+2, n+1
n-2, m+1
n-2, m-1
n+2, m+1
n+2, m-1
"""

dx = n.index
while True:
    if (dx - 2) > 0:
        if (m + 2) < 9 and (m +2):
            count += 2
        elif (m + 1) < 9:
            count += 1
풀이라고 하기도 민망한;;; 그냥 못 풀었다

 
'''
1-2. 풀이 도중 생각

- 입력이 문자와 숫자 둘 다 받기 때문에 문자도 인덱스로 바꿔서 숫자로 표현해야지

- 움직일 수 있는 경우의 수는 어짜피 8개가 한계이고, 이를 코드로 바꿔보면 m+-2, n+-2 안에서 표현 가능할 것 같다

- 그래서 구현은 어떻게 하지...? 
'''
 

 
'''
2. 정답
'''

input_data = input()
row = int(input_data[1])
column = int(ord(input_data[0])) - int(ord('a')) + 1

steps = [(-2,-1), (-2,1), (-1,-2), (-1,2), (1,-2), (1,2), (2,-1), (2,1)]

result = 0
for step in steps:
    next_row = row + step[0]
    next_colum = column + step[1]
    if next_row >=1 and next_row <=8 and next_colum >= 1 and next_colum <= 8:
        result += 1

print(result)
 

'''

3. 새로 공부하게 된 것 or 새삼 다시 알게 된 것

1) pythond의 ord(문자)

인자로 문자 하나를 받으며, 그 문자에 해당하는 유니코드 정수를 리턴하는 함수. (ex. ord('a') -> 97)

이때 a~z는 a를 기준으로 알파벳 순서대로 순차적인 유니코드 정수를 부여받았음.

문제에서는 알파벳 순서대로 정수가 1씩 증가한다는 점을 이용하여 column 값을 숫자로 변환함

 

2) 문자열에 대해서 인덱싱이 가능한 것

맨날 pandas 안에서만 인덱싱하다보니까 문자열에 대해서 인덱싱 가능한거 까먹었음...

data = 'a1'에 대해서 data[0] = 'a', data[1] = '1'

 

3) 튜플에 대해서 인덱싱이 가능한 것

문자열과 마찬가지로 맨날 리스트에서 인덱싱만 하다보니까 튜플에서 인덱싱 가능한거 까먹음 (사실 이건 처음 안 것 같기도)

data = (2,1)에 대해서 data[0] = 2, data[1] = 1

 

4) 최종적으로 이동한 위치 값에 대해서만 한꺼번에 검사하는 로직 (1보다 작은지, 8보다 크지는 않은지) 

최종적인 위치에서의 row와 column 값이 >=1, <=8만 아니라면 ok. 이걸 하나하나 쪼개서 if 문으로 묻지 않아도 됨.
'''
